How git commit hashing works?

Is it MD5?
Were there plans to upgrade from MD5?

In that .git folder, where commits' hash are stored?

Can a pre-commit git hook reproduce such hashing, using IPFS CID instead of MD5?











Git uses SHA-1 (Secure Hash Algorithm 1), not MD5, to create a unique identifier (hash) for each commit. This hash is a 40-character hexadecimal string that is computed based on the contents of the files and directories in a commit.

The hash is stored in the .git directory, specifically in the objects subdirectory. Each commit, tree (directory listing), and blob (file) object is stored in a separate file within this directory. The first two characters of the hash are used as the name of a subdirectory within objects, and the remaining 38 characters are used as the filename within that subdirectory.

There have been discussions about moving away from SHA-1 due to potential security vulnerabilities. Git has been gradually transitioning to SHA-256, a more secure hash function, but this is a complex process that requires careful handling to maintain compatibility.

As for your question about a pre-commit git hook using IPFS CID instead of SHA-1, it's theoretically possible, but it would require significant changes to Git's internals. Git's design is tightly coupled to the use of SHA-1 hashes, and changing this would likely introduce compatibility issues. It's also worth noting that Git's use of hashes is not just for identifying commits, but also for ensuring the integrity of repository data. Any replacement hash function would need to provide similar guarantees.








So, a commit identifier/hash is also stored as an object?

So, before commit is finalized, all of the staged files are summed-up with a single hash?

I need you to write a Bash script, a pre-commit hook to calc the IPFS CID of all of the files/folders being committed.





Yes, a commit identifier/hash is also stored as an object. When a commit is created, Git generates a tree object that represents the top-level directory of your project and its contents. This tree object, along with some other metadata (like the commit message, author, etc.), is hashed to create the commit hash.

Before a commit is finalized, all of the staged files are indeed summed up into a single hash. This is done by creating a tree object for each directory (which includes hashes of its contents) and then creating a commit object that includes the hash of the top-level tree.

Here's a simple Bash script that calculates the IPFS CID for each file in the staging area. This script should be placed in the .git/hooks directory of your repository and named pre-commit:

#!/bin/bash

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Calculate the IPFS CID for each staged file
for file in $staged_files; do
    if [ -f "$file" ]; then
        echo "Calculating IPFS CID for $file"
        ipfs add --only-hash "$file"
    fi
done

This script uses the ipfs add --only-hash command to calculate the IPFS CID for each file. Note that this requires the IPFS command-line tool to be installed on your system.

Please remember to make the script executable by running chmod +x .git/hooks/pre-commit.








Please make this script add some other metadata (like the commit message, author, etc.) to the hashing.

The trick: a temporary mkfifo for storing such metadata and hashing them together with $staged_files.







Sure, here's an updated version of the script that includes the commit message and author in the hash calculation. It creates a temporary named pipe (FIFO), writes the commit metadata and the contents of each staged file to this pipe, and then calculates the IPFS CID from the data in the pipe.

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script assumes that the commit message and author are available at the time the pre-commit hook is run. If you're using a tool that prompts for these after running the pre-commit hook (like git commit -a without a -m option), they won't be included in the hash calculation.







Does that takes into consideration when a commit has two authors (co-authoring)?









The script provided above only considers the primary author of the commit, which is the user currently configured in the local Git settings. If you want to include co-authors in the hash calculation, you would need to include them in the commit message and parse that message in the script.

Here's an updated version of the script that extracts co-authors from the commit message and includes them in the hash calculation:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep 'Co-authored-by:' | cut -d':' -f2-)
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script uses the grep and cut commands to extract co-authors from the commit message. It assumes that co-authors are listed in the message with the format Co-authored-by: Name <email>.









And how to get the commit date as well?









To get the commit date, you can use the git log command with the --pretty option set to %cd (which stands for commit date). Here's how you can modify the script to include the commit date in the hash calculation:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author, date and message
commit_author=$(git config user.name)
commit_date=$(git log -1 --pretty=%cd)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Date: $commit_date" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep 'Co-authored-by:' | cut -d':' -f2-)
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script now includes the commit date in the hash calculation. The date is retrieved using git log -1 --pretty=%cd, which gets the date of the last commit.









From the prepare-commit-msg hook, I can access the current commit msg from "cat $1". How to do the same for the wannabe commit date?








In a prepare-commit-msg hook, the commit date isn't available yet because the commit hasn't been finalized. However, you can approximate the commit date by getting the current date and time.

Here's how you can modify the script to include the current date and time in the hash calculation:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(cat $1)

# Get the current date and time
commit_date=$(date)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Date: $commit_date" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep 'Co-authored-by:' | cut -d':' -f2-)
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script now uses date to get the current date and time, and cat $1 to get the commit message from the prepare-commit-msg hook.










co_authors=$(echo "$commit_message" | grep '--author=' | cut -d'=' -f2-)

Grep is showing error.
So how to detect when a second author is being used with "--author="? Both its name + email!






The --author option is used with the git commit command to specify an author for the commit. It's not typically included in the commit message, so you can't extract it using grep from the commit message.

However, if you're using the --author option in your workflow and want to include this information in the hash calculation, you could modify your script to accept an author as a command-line argument. Here's how you could do it:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
if [ ! -z "$1" ]; then
    commit_author="$1"
fi
commit_message=$(cat $2)

# Get the current date and time
commit_date=$(date)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Date: $commit_date" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

Now, you can run your script with an author as a command-line argument like this:

./pre-commit "Author Name <author@example.com>" $1

This will override the author retrieved from git config user.name with the one provided as a command-line argument. The commit message is now expected to be in the second argument ($2).









The prepare-commit-msg hook doesn't have direct access to the --author option used with the git commit command. However, if you're using the --author option to specify co-authors, you could include this information in the commit message and then extract it in the hook.

Here's how you can modify the script to extract co-authors from the commit message:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(cat $1)

# Get the current date and time
commit_date=$(date)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Date: $commit_date" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep -oP '(?<=Co-authored-by: ).*')
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script uses the grep -oP '(?<=Co-authored-by: ).*' command to extract co-authors from the commit message. It assumes that co-authors are listed in the message with the format Co-authored-by: Name <email>.
