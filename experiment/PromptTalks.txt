How git commit hashing works?

Is it MD5?
Were there plans to upgrade from MD5?

In that .git folder, where commits' hash are stored?

Can a pre-commit git hook reproduce such hashing, using IPFS CID instead of MD5?











Git uses SHA-1 (Secure Hash Algorithm 1), not MD5, to create a unique identifier (hash) for each commit. This hash is a 40-character hexadecimal string that is computed based on the contents of the files and directories in a commit.

The hash is stored in the .git directory, specifically in the objects subdirectory. Each commit, tree (directory listing), and blob (file) object is stored in a separate file within this directory. The first two characters of the hash are used as the name of a subdirectory within objects, and the remaining 38 characters are used as the filename within that subdirectory.

There have been discussions about moving away from SHA-1 due to potential security vulnerabilities. Git has been gradually transitioning to SHA-256, a more secure hash function, but this is a complex process that requires careful handling to maintain compatibility.

As for your question about a pre-commit git hook using IPFS CID instead of SHA-1, it's theoretically possible, but it would require significant changes to Git's internals. Git's design is tightly coupled to the use of SHA-1 hashes, and changing this would likely introduce compatibility issues. It's also worth noting that Git's use of hashes is not just for identifying commits, but also for ensuring the integrity of repository data. Any replacement hash function would need to provide similar guarantees.








So, a commit identifier/hash is also stored as an object?

So, before commit is finalized, all of the staged files are summed-up with a single hash?

I need you to write a Bash script, a pre-commit hook to calc the IPFS CID of all of the files/folders being committed.





Yes, a commit identifier/hash is also stored as an object. When a commit is created, Git generates a tree object that represents the top-level directory of your project and its contents. This tree object, along with some other metadata (like the commit message, author, etc.), is hashed to create the commit hash.

Before a commit is finalized, all of the staged files are indeed summed up into a single hash. This is done by creating a tree object for each directory (which includes hashes of its contents) and then creating a commit object that includes the hash of the top-level tree.

Here's a simple Bash script that calculates the IPFS CID for each file in the staging area. This script should be placed in the .git/hooks directory of your repository and named pre-commit:

#!/bin/bash

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Calculate the IPFS CID for each staged file
for file in $staged_files; do
    if [ -f "$file" ]; then
        echo "Calculating IPFS CID for $file"
        ipfs add --only-hash "$file"
    fi
done

This script uses the ipfs add --only-hash command to calculate the IPFS CID for each file. Note that this requires the IPFS command-line tool to be installed on your system.

Please remember to make the script executable by running chmod +x .git/hooks/pre-commit.








Please make this script add some other metadata (like the commit message, author, etc.) to the hashing.

The trick: a temporary mkfifo for storing such metadata and hashing them together with $staged_files.







Sure, here's an updated version of the script that includes the commit message and author in the hash calculation. It creates a temporary named pipe (FIFO), writes the commit metadata and the contents of each staged file to this pipe, and then calculates the IPFS CID from the data in the pipe.

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script assumes that the commit message and author are available at the time the pre-commit hook is run. If you're using a tool that prompts for these after running the pre-commit hook (like git commit -a without a -m option), they won't be included in the hash calculation.







Does that takes into consideration when a commit has two authors (co-authoring)?









The script provided above only considers the primary author of the commit, which is the user currently configured in the local Git settings. If you want to include co-authors in the hash calculation, you would need to include them in the commit message and parse that message in the script.

Here's an updated version of the script that extracts co-authors from the commit message and includes them in the hash calculation:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author and message
commit_author=$(git config user.name)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep 'Co-authored-by:' | cut -d':' -f2-)
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script uses the grep and cut commands to extract co-authors from the commit message. It assumes that co-authors are listed in the message with the format Co-authored-by: Name <email>.









And how to get the commit date as well?









To get the commit date, you can use the git log command with the --pretty option set to %cd (which stands for commit date). Here's how you can modify the script to include the commit date in the hash calculation:

#!/bin/bash

# Create a temporary named pipe
tmp_fifo=$(mktemp -u)
mkfifo $tmp_fifo

# Get the commit author, date and message
commit_author=$(git config user.name)
commit_date=$(git log -1 --pretty=%cd)
commit_message=$(git log -1 --pretty=%B)

# Write the commit metadata to the pipe
echo "Author: $commit_author" > $tmp_fifo &
echo "Date: $commit_date" > $tmp_fifo &
echo "Message: $commit_message" > $tmp_fifo &

# Extract co-authors from the commit message and write them to the pipe
co_authors=$(echo "$commit_message" | grep 'Co-authored-by:' | cut -d':' -f2-)
if [ ! -z "$co_authors" ]; then
    echo "Co-authors: $co_authors" > $tmp_fifo &
fi

# Get a list of all staged files
staged_files=$(git diff --cached --name-only)

# Write the contents of each staged file to the pipe
for file in $staged_files; do
    if [ -f "$file" ]; then
        cat "$file" > $tmp_fifo &
    fi
done

# Calculate the IPFS CID from the data in the pipe
ipfs add --only-hash $tmp_fifo

# Clean up
rm $tmp_fifo

This script now includes the commit date in the hash calculation. The date is retrieved using git log -1 --pretty=%cd, which gets the date of the last commit.
